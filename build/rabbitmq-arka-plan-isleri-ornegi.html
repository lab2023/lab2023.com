<!DOCTYPE html>
<html class='no-js' lang='en'>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<title>lab2023 | web & mobile development, graphic design company - RabbitMQ 2 - Arka Plan İşleri Örneği
</title>
<meta content='Designers and developers for hire' name='description'>
<meta content='design, ruby, ruby on rails, ios, android, sencha, istanbul, ankara, denizli, turkey' name='keywords'>
<link href="assets/stylesheets/application.css" rel="stylesheet" /><link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" /><link href="assets/stylesheets/swiper-bundle.min.css" rel="stylesheet" />
<link href="assets/images/favicon.png" rel="icon" type="image/png" />
<meta content='RabbitMQ 2 - Arka Plan İşleri Örneği' name='description'>
<meta content='rabbitmq, amqp, bunny, ruby, arkaplan işleri, tr' name='keywords'>
<meta content='Onur Özgür ÖZKAN' name='author'>


</head>
<body id='blog'>
<header class='header'>
<div class='container'>
<div class='row'>
<div class='col-lg-2 col-lg-offset-1'>
<a href="/blog"><img class="logo pull-right" width="252" height="253" src="assets/images/logo.png" alt="Logo" />
</a></div>
<div class='col-lg-8'>
<h1>
<a href="/blog">lab2023's blog posts</a>
<a href="http://lab2023.com/feed.xml" target="_blank"><i class='fa fa-rss'></i>
</a></h1>
<div class='row'>
<div class='col-lg-3'>
<p>
<a href="/"><i class='fa fa-arrow-circle-left'></i>
lab2023.com
</a></p>
</div>
<div class='col-lg-9' id='language_linked'>
<p>
<a href="/tag/tr.html">Türkçe
</a>·
<a href="/tag/en.html">English
</a>·
<a href="/tag/es.html">Español
</a>·
<a href="/tag/ru.html">Русский
</a></p>
</div>
</div>
</div>
</div>
</div>
</header>

<!-- share-buttons js code -->
<div id='fb-root'>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/tr_TR/all.js#xfbml=1";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
  (function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs'));
</script>
</div>
<div class='container'>
<div class='row'>
<div class='col-lg-2 col-lg-offset-1 article-meta'>
<h4><a href="http://twitter.com/onurozgurozkan" target="_blank">Onur Özgür ÖZKAN</a></h4>
<h5>April 25, 2014</h5>
<span class='tag'><a href="/tag/rabbitmq.html">rabbitmq</a></span>
<span class='tag'><a href="/tag/amqp.html"> amqp</a></span>
<span class='tag'><a href="/tag/bunny.html"> bunny</a></span>
<span class='tag'><a href="/tag/ruby.html"> ruby</a></span>
<span class='tag'><a href="/tag/arkaplan-isleri.html"> arkaplan işleri</a></span>
<span class='tag'><a href="/tag/tr.html"> tr</a></span>
<!-- Share buttons -->
<ul class='share_button'>
<li>
<div class='fb-share-button' data-href='http://lab2023.com/rabbitmq-arka-plan-isleri-ornegi.html' data-type='button_count'></div>
</li>
<li>
<a class='twitter-share-button' data-text='http://lab2023.com/rabbitmq-arka-plan-isleri-ornegi.html' data-via='lab2023' href='https://twitter.com/share'></a>
</li>
<li>
<script src='//platform.linkedin.com/in.js' type='text/javascript'>
<![CDATA[
    lang: en_US
]]>
</script>
<script data-url='http://lab2023.com/rabbitmq-arka-plan-isleri-ornegi.html' type='IN/Share'></script>
</li>
</ul>
</div>
<div class='col-lg-8'>
<article class='post'>
<h1>RabbitMQ 2 - Arka Plan İşleri Örneği</h1>
<p>Bir önceki makalemizde <a href="http://lab2023.com/rabbitmq-hello-world-ornegi.html">&lsquo;RabbitMQ ile Merhaba Dünya Örneğini&rsquo;</a>
yapmıştık. Bu örneğimizde ise özellikle <a href="https://github.com/resque/resque">Resque</a>, <a href="https://github.com/collectiveidea/delayed_job/tree/master">Delayed Job</a>
gibi arka plan işler için RabbitMQ kullanacağız.</p>

<p><img alt="Örnek 2" width="332" height="111" src="assets/images/articles/2014-04-25-rabbitmq.png" /></p>

<p>Bir önceki örnekte <code>Producer</code>, <code>Consumer</code>&lsquo;ye &#39;Merhaba Dünya&rsquo; yazısı gönderiyordu. Gerçek hayatta bu işlem arka plan
işlemlere iyi bir örnek değildir. Arkaplan işleri daha çok süre gerektiren ve işlerin bir tek instance tarafından
değil de birden çok instance tarafından yapıldığı işlemlerdir. Yedek alma, rapor çıkarmak, resim düzenleme gibi işlemler
bunlara örnektir. Bu işlemlerin ortak özelliği yapılmalarının vakit almasıdır.</p>

<h2 id="haz-rl-k">Hazırlık</h2>

<p>O zaman bu örneğimizde <code>Producer</code> mesajı gönderirken onun ne kadar süreceğini de textin içinde göndersin ki gerçek bir
arkaplan işini simüle edelim. Örneğin <code>Hello ...</code> işleminin bitmesi 3 saniye sürerken <code>Hello .....</code> 5 saniye sürsün.
Her bir nokta bir saniye gibi düşünebiliriz.</p>

<p>Buna göre kodlarımızı düzenleyelim. <code>send.rb</code> artık yapılacak iş olduğundan <code>new_task.rb</code> demek daha doğru olur.</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">msg</span>  <span class="o">=</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">empty?</span> <span class="p">?</span> <span class="s2">"Hello World!"</span> <span class="p">:</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>

<span class="n">q</span><span class="p">.</span><span class="nf">publish</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ss">:persistent</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
<span class="nb">puts</span> <span class="s2">" [x] Published </span><span class="si">#{</span><span class="n">msg</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div>
<p><code>receive.rb</code> dosyamızda işi yapan kod olduğuna göre ona da <code>worker.rb</code> demek daha doğru olacaktır.</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">q</span><span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="ss">:ack</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:block</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">delivery_info</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">body</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">" [x] Received </span><span class="si">#{</span><span class="n">body</span><span class="si">}</span><span class="s2">"</span>
  <span class="c1"># imitate some work</span>
  <span class="nb">sleep</span> <span class="n">body</span><span class="p">.</span><span class="nf">count</span><span class="p">(</span><span class="s2">"."</span><span class="p">).</span><span class="nf">to_i</span>
  <span class="nb">puts</span> <span class="s2">" [x] Done"</span>

  <span class="n">ch</span><span class="p">.</span><span class="nf">ack</span><span class="p">(</span><span class="n">delivery_info</span><span class="p">.</span><span class="nf">delivery_tag</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Scriptlerimizi çalıştırabiliriz. Unutmayın scriptleri ayrı ayrı terminal tablarda çalıştırmalısınız.</p>
<div class="highlight"><pre class="highlight shell"><code>shell1<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> worker.rb
shell2<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> new_task.rb
</code></pre></div>
<h2 id="s-ra-ile-da-tma">Sıra ile dağıtma</h2>

<p>Worker Queue&#39;nin en büyük avantajı yapılacak işlerin paralel yapılabilmesidir. Çok rahat bir şekilde yeni workerlar ekleyip uygulamanızı ölçeklendirebilirsiniz.</p>

<p>Aynı anda iki worker çalıştırırsanız aşağıdaki sonucu alacaksınız.</p>
<div class="highlight"><pre class="highlight shell"><code>shell1<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> worker.rb
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Waiting <span class="k">for </span>messages. To <span class="nb">exit </span>press CTRL+C
</code></pre></div><div class="highlight"><pre class="highlight shell"><code>shell2<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> worker.rb
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Waiting <span class="k">for </span>messages. To <span class="nb">exit </span>press CTRL+C
</code></pre></div>
<p>Mesajlarımızı gönderelim</p>
<div class="highlight"><pre class="highlight shell"><code>shell3<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> new_task.rb First message.
shell3<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> new_task.rb Second message..
shell3<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> new_task.rb Third message...
shell3<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> new_task.rb Fourth message....
shell3<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> new_task.rb Fifth message.....
</code></pre></div>
<p>Shell1 ve Shell2 için çıktılar</p>
<div class="highlight"><pre class="highlight shell"><code>shell1<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> worker.rb
 <span class="o">[</span><span class="k">*</span><span class="o">]</span> Waiting <span class="k">for </span>messages. To <span class="nb">exit </span>press CTRL+C
 <span class="o">[</span>x] Received <span class="s1">'First message.'</span>
 <span class="o">[</span>x] Received <span class="s1">'Third message...'</span>
 <span class="o">[</span>x] Received <span class="s1">'Fifth message.....'</span>
</code></pre></div><div class="highlight"><pre class="highlight shell"><code>shell2<span class="nv">$ </span>ruby <span class="nt">-rubygems</span> worker.rb
 <span class="o">[</span><span class="k">*</span><span class="o">]</span> Waiting <span class="k">for </span>messages. To <span class="nb">exit </span>press CTRL+C
 <span class="o">[</span>x] Received <span class="s1">'Second message..'</span>
 <span class="o">[</span>x] Received <span class="s1">'Fourth message....'</span>
</code></pre></div>
<p>Gördüğünüz gibi yapılacak işler shell1 ve shell2 arasında paylaşılmaktadir.</p>

<h2 id="mesajlar-n-bildirilmesi">Mesajların bildirilmesi</h2>

<p>Peki <code>Consumers</code> bu uzun işlemleri yaparken bir hata ile karşılaşıp ölür ise ne olur? Şuanki kodumuza göre o işlem yapılmamış olur çünkü RabbitMQ mesajın gönderilmesi ile ilgili mesajı hafızadan siler. Bu durumda hem iş yapılmamış olur, hemde mesaj gönderildiği anda hafızadan silindiği için tekrar kuyruğa atma şansımız olmaz.</p>

<p>Mesajların kaybolmasını engellemek için RabbitMQ <code>acknowledgments</code> özelliğini sunar. Basitçe anlatmak gerekir ise <code>ack(nowledgement)</code> mesajın başarı ile alındığını ve işlem gerçekleşince <code>consumer</code>&lsquo;a bir mesaj ile bildirir. Bundan sonra RabbitMQ hafızadan mesajı siler.</p>

<p>Eğer <code>consumer</code> ack göndermeden ölür ise, RabbitMQ bu mesajın yerine ulaşmadığını veya işlemin başarı ile tamamlanmadığını anlar. Hafızasından silmediği mesajı başka bir <code>consumer</code>&#39;a gönderir.</p>

<p>Mesajlar için bir timeout yoktur. RabbitMQ mesajları ancak worker connectionları ölür ise tekrar dağıtır.</p>

<p>Varsayılan olarak <code>ack</code> özelliği kapalı gelir. Aktifleştirmek için <code>:manuel_ack =&gt; true</code> parametresi <code>subscribe</code> methoduna eklenmelidir.</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">q</span><span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="ss">:manual_ack</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:block</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">delivery_info</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">body</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">" [x] Received '</span><span class="si">#{</span><span class="n">body</span><span class="si">}</span><span class="s2">'"</span>
  <span class="c1"># imitate some work</span>
  <span class="nb">sleep</span> <span class="mf">1.0</span>
  <span class="nb">puts</span> <span class="s2">" [x] Done"</span>
  <span class="n">ch</span><span class="p">.</span><span class="nf">ack</span><span class="p">(</span><span class="n">delivery_info</span><span class="p">.</span><span class="nf">delivery_tag</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Ack özelliğini worker çalışırken workerı <code>CTRL+C</code> komutu ile öldürerek deneyebilirsiniz.</p>

<p><strong>Unutulan acknowledgementlar</strong></p>

<p><code>ack</code>&#39;ların unutulması çok sık yapılan bir hatadır ama etkileri ciddi olur. Istemciler çıktığında RabbitMQ mesajları otomatik olarak tekrar dağıtır. Geliştiriciler bu dağıtımların nedenlerini anlayamaz. Tabii bu dağıtımlar katlanarak RAM ve CPU kullanımının artmasına neden olur. Bu durumu debug etmek için <code>rabbitmqctl</code> komutunu kullanabilirsiniz.</p>
<div class="highlight"><pre class="highlight shell"><code><span class="nv">$ </span><span class="nb">sudo </span>rabbitmqctl list_queues name messages_ready messages_unacknowledged
  Listing queues ...
  hello    0       0
  ...done.
</code></pre></div>
<h2 id="mesajlar-n-devaml-l">Mesajların devamlılığı</h2>

<p>Peki workerlar değilde RabbitMQ&#39;nun kendisi kapanırsa veya restart olursa mesajlarımız ne olur? Böyle bir senaryoda mevcut kodlar ile sadece mesajlar değil kuyraklarda kaybolur. Hiçbir kayıp yaşamak istemiyorsak hem kuyrukları hem mesajları korumamız gerekiyor.</p>

<p>Ilk önce RabbitMQ&#39;nun kuyrukları kaybetmemesini sağlayalım. Bunun içın kuyruklara <code>:durable =&gt; true</code> parametresini geçiyoruz.</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">ch</span><span class="p">.</span><span class="nf">queue</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">,</span> <span class="ss">:durable</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
</code></pre></div>
<p>Mevcut bir kanala <code>:durable =&gt; true</code> ifadesini geçtiğimiz zaman RabbitMQ size hata verecektir çünkü kanallara sonradan <code>durable</code> eklenemez. Bu problemi çözmenin en basit yolu kanalın ismini değiştirmektir.</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">ch</span><span class="p">.</span><span class="nf">queue</span><span class="p">(</span><span class="s1">'task_queue'</span><span class="p">,</span> <span class="ss">:durable</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
</code></pre></div>
<p>Diğer unutulmaması gereken konu <code>durable</code> parametresinin hem <code>consumer</code> hem de <code>producer</code>&#39;a uyarlanması gerektiğidir. Bu eklemeden sonra RabbitMQ yeniden başlatılsa bile kuyruklar kaybolmayacaktır.</p>

<p>Mesajların sürekliliği içinde <code>:persistent =&gt; true</code> parametresini eklemeliyiz.</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">x</span><span class="p">.</span><span class="nf">publish</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ss">:persistent</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
</code></pre></div>
<p><strong>Mesajların sürekliliği</strong></p>

<p>Mesajlarınızı <code>persistent</code> yapmak mesajlarınızın kaybolmamasını yüzde yüz garanti altına almıyor. <code>persistent</code> işlemi mesajlarınızın diske yazılmasını sağlıyor. Bu kısa sürede çok küçükte olsa mesajlarınızın kaybolma riski vardır. Daha kesin bir çözüm için publish kodunuzu transaction bloku içine almanızdır.</p>

<h2 id="mesajlar-n-adil-da-t-lmas">Mesajların adil dağıtılması</h2>

<p>Bazen kuyruktaki mesajlar istediğiniz gibi dağılmaz. Bunu söyle bir durum ile özetleyelim. Örneğin tekil mesajlar basit iken, çoğul mesajlar zor olsun. Böyle bir durumda workerlardan biri sürekli çalışırken diğeri sürekli beklemede olacaktır.</p>

<p>Bunun nedeni basittir. RabbitMQ, kuyruktaki mesajları dağıtırken <code>consumer</code>ların unacknowledge mesaj sayısına bakmaz. RabbitMQ bu konuda kör gibi davranır. Gelen N mesajı N tane workera eşit sayıda dağıtır.</p>

<p>Bunu engellemenin yolu bir workerın elindeki iş bitmeden yeni bir iş atanmasını engellemek daha doğru bir ifade ile aynı anda kaç iş yapabileceğini <code>prefetch</code> methodu ile belirlemektir.</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">ch</span><span class="p">.</span><span class="nf">prefetch</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</code></pre></div>
<p>Eğer workerlar çok yoğun ise yeni bir worker sisteme eklenebilir. Bunun ile ilgili bir strateji geliştirebilirsiniz.</p>

<h2 id="hepsi-bir-arada">Hepsi bir arada</h2>

<p>Son olarak bütün kodların son hallerini toplayalım.</p>

<p>new_task.rb</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="c1">#!/usr/bin/env ruby</span>
<span class="c1"># encoding: utf-8</span>

<span class="nb">require</span> <span class="s2">"bunny"</span>

<span class="n">conn</span> <span class="o">=</span> <span class="no">Bunny</span><span class="p">.</span><span class="nf">new</span>
<span class="n">conn</span><span class="p">.</span><span class="nf">start</span>

<span class="n">ch</span>   <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">create_channel</span>
<span class="n">q</span>    <span class="o">=</span> <span class="n">ch</span><span class="p">.</span><span class="nf">queue</span><span class="p">(</span><span class="s2">"task_queue"</span><span class="p">,</span> <span class="ss">:durable</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>

<span class="n">msg</span>  <span class="o">=</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">empty?</span> <span class="p">?</span> <span class="s2">"Hello World!"</span> <span class="p">:</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>

<span class="n">q</span><span class="p">.</span><span class="nf">publish</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ss">:persistent</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
<span class="nb">puts</span> <span class="s2">" [x] Sent </span><span class="si">#{</span><span class="n">msg</span><span class="si">}</span><span class="s2">"</span>

<span class="nb">sleep</span> <span class="mf">1.0</span>
<span class="n">conn</span><span class="p">.</span><span class="nf">close</span>
</code></pre></div>
<p>worker.rb</p>
<div class="highlight"><pre class="highlight ruby"><code><span class="c1">#!/usr/bin/env ruby</span>
<span class="c1"># encoding: utf-8</span>

<span class="nb">require</span> <span class="s2">"bunny"</span>

<span class="n">conn</span> <span class="o">=</span> <span class="no">Bunny</span><span class="p">.</span><span class="nf">new</span>
<span class="n">conn</span><span class="p">.</span><span class="nf">start</span>

<span class="n">ch</span>   <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">create_channel</span>
<span class="n">q</span>    <span class="o">=</span> <span class="n">ch</span><span class="p">.</span><span class="nf">queue</span><span class="p">(</span><span class="s2">"task_queue"</span><span class="p">,</span> <span class="ss">:durable</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>

<span class="n">ch</span><span class="p">.</span><span class="nf">prefetch</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">puts</span> <span class="s2">" [*] Waiting for messages. To exit press CTRL+C"</span>

<span class="k">begin</span>
  <span class="n">q</span><span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="ss">:ack</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:block</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">delivery_info</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">body</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">" [x] Received '</span><span class="si">#{</span><span class="n">body</span><span class="si">}</span><span class="s2">'"</span>
    <span class="c1"># imitate some work</span>
    <span class="nb">sleep</span> <span class="mf">1.0</span>
    <span class="nb">puts</span> <span class="s2">" [x] Done"</span>
    <span class="n">ch</span><span class="p">.</span><span class="nf">ack</span><span class="p">(</span><span class="n">delivery_info</span><span class="p">.</span><span class="nf">delivery_tag</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="no">Interrupt</span> <span class="o">=&gt;</span> <span class="n">_</span>
  <span class="n">conn</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div>
<p>Konu ile ilgili daha detaylı bilgi almak için <a href="http://reference.rubybunny.info/">Bunny API Referanslarına</a> bakabilirsiniz.</p>

<p>Saygılar.</p>

<h3 id="kaynaklar">Kaynaklar</h3>

<ul>
<li><a href="https://www.rabbitmq.com/tutorials/tutorial-two-ruby.html">https://www.rabbitmq.com/tutorials/tutorial-two-ruby.html</a></li>
</ul>

<div id='disqus_thread'></div>
<script>
  var disqus_shortname = 'lab2023';
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>
Please enable JavaScript to view the
<a href='http://disqus.com/?ref_noscript'>comments powered by Disqus.</a>
</noscript>
<a class='dsq-brlink' href='http://disqus.com'>
comments powered by
<span class='logo-disqus'>Disqus</span>
</a>
</article>
</div>
</div>
</div>
<footer class='footer'>
<h4>© 2009 ~ 2020 LAB2023, CORP.</h4>
<p>The all designs, materials and contents trademarks of lab2023, corp.</p>
</footer>

</body>
<!-- Javascripts -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.7.1/modernizr.min.js"></script><script src="assets/javascripts/vendor/swiper-bundle.min.js"></script><script src="assets/javascripts/application.js"></script>
<script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-12243799-3']);
  _gaq.push(['_trackPageview']);
  
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</html>
